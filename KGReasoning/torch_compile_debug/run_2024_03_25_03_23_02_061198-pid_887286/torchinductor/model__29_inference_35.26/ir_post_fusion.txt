buf0_buf1_buf2: FusedSchedulerNode(NoneType)
buf0_buf1_buf2.writes = 
    [   MemoryDep('buf0', c0, {c0: s0*s2}),
        MemoryDep('buf1', c0, {c0: s0*s2}),
        MemoryDep('buf2', c0, {c0: s0*s2})]
buf0_buf1_buf2.unmet_dependencies = []
buf0_buf1_buf2.met_dependencies = 
    [   MemoryDep('arg0_1', 0, {}),
        MemoryDep('arg3_1', c1, {c0: s2, c1: s0*s1}),
        MemoryDep('arg5_1', c0*s1 + c2, {c0: s2, c1: s0, c2: s1}),
        MemoryDep('arg6_1', c0*s1 + c2, {c0: s2, c1: s0, c2: s1})]
buf0_buf1_buf2.users = []
    buf0_buf1_buf2.snodes[0] =
    buf0: SchedulerNode(ComputedBuffer)
    buf0.writes = [MemoryDep('buf0', c0, {c0: s0*s2})]
    buf0.unmet_dependencies = []
    buf0.met_dependencies = 
        [   MemoryDep('arg3_1', c1, {c0: s2, c1: s0*s1}),
            MemoryDep('arg5_1', c0*s1 + c2, {c0: s2, c1: s0, c2: s1}),
            MemoryDep('arg6_1', c0*s1 + c2, {c0: s2, c1: s0, c2: s1})]
    buf0.users = [NodeUser(node=SchedulerNode(name='buf2'), can_inplace=True, is_weak=False)]
    buf0.group.device = cuda:0
    buf0.group.iteration = (s0*s2, s1)
    buf0.sizes = ([s2, s0], [s1])
    class buf0_loop_body:
        var_ranges = {z0: s2, z1: s0, z2: s1}
        index0 = s1*z1 + z2
        index1 = s1*z0 + z2
        index2 = s0*z0 + z1
        def body(self, ops):
            get_index = self.get_index('index0')
            load = ops.load('arg3_1', get_index)
            get_index_1 = self.get_index('index1')
            load_1 = ops.load('arg5_1', get_index_1)
            sub = ops.sub(load, load_1)
            abs_1 = ops.abs(sub)
            get_index_2 = self.get_index('index1')
            load_2 = ops.load('arg6_1', get_index_2)
            sub_1 = ops.sub(abs_1, load_2)
            relu = ops.relu(sub_1)
            abs_2 = ops.abs(relu)
            reduction = ops.reduction(torch.float32, torch.float32, 'sum', abs_2)
            get_index_3 = self.get_index('index2')
            store_reduction = ops.store_reduction('buf0', get_index_3, reduction)
            return store_reduction
    buf0_buf1_buf2.snodes[1] =
    buf1: SchedulerNode(ComputedBuffer)
    buf1.writes = [MemoryDep('buf1', c0, {c0: s0*s2})]
    buf1.unmet_dependencies = []
    buf1.met_dependencies = 
        [   MemoryDep('arg3_1', c1, {c0: s2, c1: s0*s1}),
            MemoryDep('arg5_1', c0*s1 + c2, {c0: s2, c1: s0, c2: s1}),
            MemoryDep('arg6_1', c0*s1 + c2, {c0: s2, c1: s0, c2: s1})]
    buf1.users = [NodeUser(node=SchedulerNode(name='buf2'), can_inplace=True, is_weak=False)]
    buf1.group.device = cuda:0
    buf1.group.iteration = (s0*s2, s1)
    buf1.sizes = ([s2, s0], [s1])
    class buf1_loop_body:
        var_ranges = {z0: s2, z1: s0, z2: s1}
        index0 = s1*z1 + z2
        index1 = s1*z0 + z2
        index2 = s0*z0 + z1
        def body(self, ops):
            get_index = self.get_index('index0')
            load = ops.load('arg3_1', get_index)
            get_index_1 = self.get_index('index1')
            load_1 = ops.load('arg5_1', get_index_1)
            sub = ops.sub(load, load_1)
            abs_1 = ops.abs(sub)
            get_index_2 = self.get_index('index1')
            load_2 = ops.load('arg6_1', get_index_2)
            minimum = ops.minimum(abs_1, load_2)
            abs_2 = ops.abs(minimum)
            reduction = ops.reduction(torch.float32, torch.float32, 'sum', abs_2)
            get_index_3 = self.get_index('index2')
            store_reduction = ops.store_reduction('buf1', get_index_3, reduction)
            return store_reduction
    buf0_buf1_buf2.snodes[2] =
    buf2: SchedulerNode(ComputedBuffer)
    buf2.writes = [MemoryDep('buf2', c0, {c0: s0*s2})]
    buf2.unmet_dependencies = [MemoryDep('buf0', c0, {c0: s0*s2}), MemoryDep('buf1', c0, {c0: s0*s2})]
    buf2.met_dependencies = [MemoryDep('arg0_1', 0, {})]
    buf2.users = [NodeUser(node=OUTPUT, can_inplace=False, is_weak=False)]
    buf2.group.device = cuda:0
    buf2.group.iteration = (s0*s2, 1)
    buf2.sizes = ([s0*s2], [])
    class buf2_loop_body:
        var_ranges = {z0: s0*s2}
        index0 = 0
        index1 = z0
        def body(self, ops):
            get_index = self.get_index('index0')
            load = ops.load('arg0_1', get_index)
            get_index_1 = self.get_index('index1')
            load_1 = ops.load('buf0', get_index_1)
            sub = ops.sub(load, load_1)
            get_index_2 = self.get_index('index1')
            load_2 = ops.load('buf1', get_index_2)
            constant = ops.constant(0.02, torch.float32)
            mul = ops.mul(load_2, constant)
            sub_1 = ops.sub(sub, mul)
            get_index_3 = self.get_index('index1')
            store = ops.store('buf2', get_index_3, sub_1, None)
            return store


